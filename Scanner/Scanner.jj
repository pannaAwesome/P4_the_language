options {
  IGNORE_CASE = false;
}

PARSER_BEGIN(Scanner)

import java.io.*;

public class Scanner {

    public static void main(String[] args) throws FileNotFoundException
    {
        try {
            new Scanner(new java.io.FileInputStream(args[0])).PROG();
            System.out.println("Syntax is okay");
        } catch (Throwable e) {
            // Catching Throwable is ugly but JavaCC throws Error objects!
            System.out.println("Syntax check failed: " + e.getMessage());
        }
    }
}
/*
public class Scanner {

    public static void main(String[] args) throws FileNotFoundException
    {
        if ( args.length < 1 ) {
       System.out.println("Please pass in the filename for a parameter.");
       System.exit(1);
    }

    SimpleCharStream stream = new SimpleCharStream(
                                  new FileInputStream(args[0]),0,0);
    Token temp_token = null;

    ScannerTokenManager TkMgr = new ScannerTokenManager(stream);

    do {
        temp_token = TkMgr.getNextToken();

        switch(temp_token.kind) {
            case IMPORT:
                System.out.print(" IMPORT ");
                break;
            case IN:
                System.out.print(" IN ");
                break;
            case MODEL:
                System.out.print(" MODEL ");
                break;
            case BLOCKSTART:
                System.out.print(" BLOCKSTART ");
                break;
            case BLOCKSTOP:
                System.out.print(" BLOCKSTOP ");
                break;
            case COMPARISON:
                System.out.print(" COMPARISON ");
                break;
            case EQUAL:
                System.out.print(" EQUAL ");
                break;
            case LOGICAL:
                System.out.print(" LOGICAL ");
                break;
            case IS:
                System.out.print(" IS ");
                break;
            case DEFINERULE:
                System.out.print(" DEFINERULE ");
                break;
            case CONSTRAINT:
                System.out.print(" CONSTRAINT ");
                break;
            case ANALYZE:
                System.out.print(" ANALYZE ");
                break;
            case WITH:
                System.out.print(" WITH ");
                break;
            case FILENAME:
                System.out.print(" FILENAME ");
                break;
            case ID:
                System.out.print(" ID ");
                break;
            case EOL:
                System.out.println("    EOL");
                break;
            case STRING:
                System.out.print("STRING");
                break;
         default:
           if ( temp_token.kind != EOF )
             System.out.println("OTHER: " + temp_token.image);
           break;
        }
    } while (temp_token.kind != EOF);
    }
}
*/
PARSER_END(Scanner)

SKIP: /* Whitespace */
{
  "\t"
| "\r"
| " "
}

TOKEN: /* Keywords */
{
    <IMPORT:        "IMPORT">
|   <IN:            "IN">
|   <MODEL:         "MODEL">
|   <BLOCKSTART:    "BEGIN">
|   <BLOCKSTOP:     "END">
|   <ANALYZE:       "ANALYZE">
|   <WITH:          "WITH">
}

TOKEN: /* Whitespace */
{
    <EOL:           "\n">
}

TOKEN: /* Operators */
{
    <COMPARISON:    "<=" | ">=" | "<" | ">" >
|   <EQUAL:         "=">
|   <LOGICAL:       "AND" | "OR" >
|   <DEFINERULE:    ":" >
|   <IS:            "IS" >
}

TOKEN: /* Regex */
{
    <CONSTRAINT:    "LETTERS"|"NUMBERS">
}

TOKEN: /* Identifiers */
{
    <FILENAME:      (["A"-"Z","a"-"z","0"-"9","-","_"])+".csv">
|   <ID:            (["A"-"Z","a"-"z"](["A"-"Z","a"-"z","0"-"9","_"])*)|("_"(["A"-"Z","a"-"z","0"-"9"])(["A"-"Z","a"-"z","0"-"9","_"])*)>
}

TOKEN: /* Literals */
{
    <INT:           ["1"-"9"](["0"-"9"])* | "0" >
|   <FLOAT:         "0" "." (["0"-"9"])+ | ["1"-"9"] (["0"-"9"])* "." (["0"-"9"])+ >
|   <STRING:        "\"" (~["\""])* "\"" >
}

MORE :
{
    "//" : IN_COMMENT
}

<IN_COMMENT>
SPECIAL_TOKEN :
{
  <COMMENT: "//" > : DEFAULT
}

<IN_COMMENT>
MORE :
{
  < ~[] >
}

//void PROG():    {}  { STMT() }
void PROG():    {}  { MDL() IMPRT() STMT() }
void STMT():    {}  { ANLZ() (<EOL>)+ STMT() | <EOF>  }
void ANLZ():    {}  { <ANALYZE> <ID> <WITH> <ID> }
void IMPRT():   {}  { <IMPORT> <FILENAME> <IN> <ID> ((<EOL>)+) }
void MDL():     {}  { <MODEL> <ID> <BLOCKSTART> (<EOL>)+ (RLE())* <BLOCKSTOP> ((<EOL>)+) }
void RLE():     {}  { <ID> <DEFINERULE> EXPR() (<EOL>)+ }
void EXPR():    {}  { SUBEXPR() (<LOGICAL> SUBEXPR())* }
void SUBEXPR(): {}  { <ID> (<IS> <CONSTRAINT> | <EQUAL> (<STRING> | NUM()) | <COMPARISON> NUM())}
void NUM():     {}  { <INT> | <FLOAT> }