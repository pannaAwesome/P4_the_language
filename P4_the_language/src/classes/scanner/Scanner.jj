/*@bgen(jjtree) Generated By:JJTree: Do not edit this line. Scanner.jj */
/*@egen*/options {
               
                 
                   
                                   
                                     
}

PARSER_BEGIN(Scanner)
package src.classes.scanner;

import src.classes.exceptions.*;
import src.classes.types.*;
import src.classes.visitors.*;


import java.io.*;
import java.util.HashMap;

public class Scanner/*@bgen(jjtree)*/implements ScannerTreeConstants/*@egen*/ {/*@bgen(jjtree)*/
  protected static JJTScannerState jjtree = new JJTScannerState();

/*@egen*/
static Scanner parser = null;
public static String prettyPrint = "";
public static void main(String[] args) {
        if(args.length == 0) {
            String[] files = {
                "./ExceptionsTestFiler/StringRegelTest.txt",
                "./ExceptionsTestFiler/DecimalRegelTest.txt",
                "./ExceptionsTestFiler/IntegerRegelTest.txt",
                "./ExceptionsTestFiler/TypeRegelTest.txt",
                "./ExceptionsTestFiler/TipRegelTest.txt"
            };

            for (String fileName : files) {
                
                try {
                    File file = new File(fileName);
                    FileInputStream stream = new FileInputStream(file);
                    
                    if (parser == null) {
                    parser = new Scanner(stream);
                    } else {
                    parser.ReInit(stream);
                    SymbolTableVisitor.ST =  new HashMap<String, STVal>();
                    TypeCheckVisitor.error = 0;
                    TypeCheckVisitor.warning = 0;
                    TypeCheckVisitor.tip = 0;
                    }

                    System.out.println(file.getName());
                    SimpleNode n = parser.PROG();
                    //n.dump("");

                    System.out.println("Pretty printing:");
                    PrettyPrinterVisitor ppv = new PrettyPrinterVisitor();
                    n.jjtAccept(ppv, null);
                    System.out.println(ppv.print);

                    System.out.println("Filling the symboltable:");
                    SymbolTableVisitor stv = new SymbolTableVisitor();
                    n.jjtAccept(stv, null);
                    System.out.println(SymbolTableVisitor.ST);
                    SymbolTableVisitor.printWrongs();
                    if(SymbolTableVisitor.error == 0) {
                        System.out.println();
                        System.out.println("Checking types:");
                        TypeCheckVisitor tcv = new TypeCheckVisitor();
                        n.jjtAccept(tcv, null);
                        TypeCheckVisitor.printWrongs();
                        if(TypeCheckVisitor.error == 0) {
                            System.out.println("Finished succesfully");
                            CodeGeneratorVisitor cgv = new CodeGeneratorVisitor();
                            n.jjtAccept(cgv, null);
                            cgv.getPyFile();
                        }
                    }
                }catch(Exception e) {
                    System.out.println(e.getMessage());
                    e.printStackTrace();
                }
            }
        } else {
            try {
                File file = new File(args[0]);
                FileInputStream stream = new FileInputStream(file);
                
                if (parser == null) {
                    parser = new Scanner(stream);
                } else {
                    parser.ReInit(stream);
                    SymbolTableVisitor.ST =  new HashMap<String, STVal>();
                    TypeCheckVisitor.error = 0;
                    TypeCheckVisitor.warning = 0;
                    TypeCheckVisitor.tip = 0;
                }
                SimpleNode n = parser.PROG();

                PrettyPrinterVisitor ppv = new PrettyPrinterVisitor();
                n.jjtAccept(ppv, null);
                prettyPrint = ppv.print;
            }catch(Exception e) {
                System.out.println(e.getMessage());
                e.printStackTrace();
            }
        }       
    }
}

PARSER_END(Scanner)

SKIP: /* Whitespace */
{
  "\t"
| "\r"
| " "
}

TOKEN: /* Keywords */
{
    <IMPORT:        "IMPORT">
|   <IN:            "IN">
|   <MODEL:         "MODEL">
|   <ANALYZE:       "ANALYZE">
|   <WITH:          "WITH">
|   <ROW:           "ROW">
|   <COL:           "COL">
|   <NOHEADERS:     "NOHEADERS">
|   <IDKEY:         "ID">
|   <TO:            "TO">
|   <WHERE:         "WHERE">
}

TOKEN: /* Whitespace */
{
    <EOL:           "\n">
}

TOKEN: /* Operators */
{
    <COMPARISON:    "<=" | ">=" | "<" | ">">
|   <EQUAL:         "=">
|   <DEFINERULE:    ":" >
|   <IS:            "IS" >
|   <OR:            "OR">
|   <AND:           "AND">
|   <NOT:           "NOT">
|   <SUM:           "SUM">
|   <AVG:           "AVG">
|   <COUNT:         "COUNT">
|   <DISTINCT:      "DISTINCT">
}

TOKEN: /* Regex */
{
    <CONSTRAINT:    "LETTERS"|"DECIMAL"|"INTEGER">
|   <EMPTY:         "EMPTY">
|   <CONTAINS:      "CONTAINS">
}

TOKEN: /* Delimiters */
{
    <COMMA:      ",">
|   <LPAREN:     "(">
|   <RPAREN:     ")">
|   <ARGSSTART:  "BEGIN">
|   <ARGSSTOP:   "END">
}

TOKEN: /* Literals */
{
    <INT:           ("-")?["1"-"9"](["0"-"9"])* | ("-")?"0" >
|   <FLOAT:         ("-")?"0" "." (["0"-"9"])+ | ("-")?["1"-"9"] (["0"-"9"])* "." (["0"-"9"])+ >
|   <STRING:        "\"" (~["\""])* "\"" >
}

TOKEN: /* Identifiers */
{
    <FILENAME:      (["A"-"Z","a"-"z","0"-"9","-","_", "/", ".", ":"])+".csv">
|   <ID:            (["A"-"Z","a"-"z"](["A"-"Z","a"-"z","0"-"9","_"])*)|("_"(["A"-"Z","a"-"z","0"-"9"])(["A"-"Z","a"-"z","0"-"9","_"])*)>
}


MORE :
{
    "//" : IN_COMMENT
}

<IN_COMMENT>
SPECIAL_TOKEN :
{
  <COMMENT: "//" > : DEFAULT
}

<IN_COMMENT>
MORE :
{
  < ~[] >
}

SimpleNode PROG():    {/*@bgen(jjtree) PROG */
  PROG jjtn000 = new PROG(JJTPROG);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}  
{/*@bgen(jjtree) PROG */
    try {
/*@egen*/ 
    (MDL() IMPRT() STMT() | IMPRT() MDL() STMT())/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/ 
    { return jjtn000; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void IMPRT()        :   
{/*@bgen(jjtree) IMPORT */
  IMPORT jjtn000 = new IMPORT(JJTIMPORT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}  
{/*@bgen(jjtree) IMPORT */
  try {
/*@egen*/ <IMPORT> FLNM() <IN> IDEN() (<ARGSSTART> (<EOL>)+ IMOPTIONS() <ARGSSTOP>)? (<EOL>)+/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/ }

void IMOPTIONS()            :
{/*@bgen(jjtree) IMPOPTIONS */
  IMPOPTIONS jjtn000 = new IMPOPTIONS(JJTIMPOPTIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) IMPOPTIONS */
    try {
/*@egen*/
    NOHEADERS() (<EOL>)+ (<IDKEY> (IDEN() | INTEGER()) (<EOL>)+)? 
|   <IDKEY> (IDEN() | INTEGER()) (<EOL>)+ (NOHEADERS() (<EOL>)+)?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FLNM():    
{/*@bgen(jjtree) FLNM */
  FLNM jjtn000 = new FLNM(JJTFLNM);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) FLNM */
    try {
/*@egen*/
    t = <FILENAME>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.value = t.image;
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NOHEADERS()           :
{/*@bgen(jjtree) NOHEADERS */
  NOHEADERS jjtn000 = new NOHEADERS(JJTNOHEADERS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) NOHEADERS */
    try {
/*@egen*/
    <NOHEADERS>/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void MDL()       :     
{/*@bgen(jjtree) MODEL */
  MODEL jjtn000 = new MODEL(JJTMODEL);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}  
{/*@bgen(jjtree) MODEL */
  try {
/*@egen*/ <MODEL> IDEN() <ARGSSTART> (<EOL>)+ (RLE() | COLRLE())* <ARGSSTOP> (<EOF> | (<EOL>)+)/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void COLRLE()      :
{}
{/*@bgen(jjtree) #COLRULE(> 1) */
    {
      COLRULE jjtn001 = new COLRULE(JJTCOLRULE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/ 
    ( <COL> IDEN() (
        <DEFINERULE> COLEXPR() (WHERE())? (<EOL>)+
    |   <ARGSSTART> (<EOL>)+ (COLPARTRLE())+ <ARGSSTOP> (<EOL>)+
    )
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
      }
    }
/*@egen*/             
}

void COLPARTRLE()             :
{/*@bgen(jjtree) COLPARTRULE */
  COLPARTRULE jjtn000 = new COLPARTRULE(JJTCOLPARTRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) COLPARTRULE */
    try {
/*@egen*/
    IDEN() <DEFINERULE> COLEXPR() (WHERE())? (<EOL>)+/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void COLEXPR()      :
{}
{
   COLOREXPR()
}

void COLOREXPR()      :
{ int count = 0; }
{/*@bgen(jjtree) #COLOR( count > 0) */
    {
      COLOR jjtn001 = new COLOR(JJTCOLOR);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (COLANDEXPR() (<OR> { count++; } COLANDEXPR())*)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  count > 0);
      }
    }
/*@egen*/               
}

void COLANDEXPR()      :
{ int count = 0; }
{/*@bgen(jjtree) #COLAND( count > 0) */
    {
      COLAND jjtn001 = new COLAND(JJTCOLAND);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (COLVPEXPR() (<AND> { count++; } COLVPEXPR())*)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  count > 0);
      }
    }
/*@egen*/                
}

void COLVPEXPR()      :
{}
{
    COLVALEXPR()
    | <LPAREN> COLEXPR() <RPAREN>
}

void COLVALEXPR():
{/*@bgen(jjtree) COLVALEXPR */
  COLVALEXPR jjtn000 = new COLVALEXPR(JJTCOLVALEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) COLVALEXPR */
    try {
/*@egen*/
    SACD() (t = <EQUAL> { jjtn000.value = t.image;} | t = <COMPARISON> { jjtn000.value = t.image;}) COLARITHMEXPR()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void WHERE():
{/*@bgen(jjtree) WHERE */
  WHERE jjtn000 = new WHERE(JJTWHERE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) WHERE */
    try {
/*@egen*/
    <WHERE> EXPR()/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void SACD():
{/*@bgen(jjtree) SACD */
  SACD jjtn000 = new SACD(JJTSACD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) SACD */
    try {
/*@egen*/
    (t = <SUM> | t = <AVG> | t = <COUNT> | t = <DISTINCT>) <LPAREN> IDEN() <RPAREN>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { jjtn000.value = t.image; }/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void COLARITHMEXPR()      :
{ Token t; ADD current; }
{
    (
    COLARITHMEXPR2()
    (
    (   t = "+" COLARITHMEXPR2()
    |   t = "-" COLARITHMEXPR2()
    )
    {
        SimpleNode first = (SimpleNode) jjtree.popNode();
        SimpleNode second = (SimpleNode) jjtree.popNode();
        current = new ADD(first.id);
        current.value = t.image;
        current.jjtAddChild(first, 0);
        current.jjtAddChild(second, 1);
        jjtree.pushNode(current);
    }
    )*
    )
}

void COLARITHMEXPR2()      :
{ Token t; MULT mult; }
{
    COLOPERANDS() 
    (
        (
            t = "*" COLOPERANDS()
        |   t = "/" COLOPERANDS()
        |   t = "%" COLOPERANDS()
        )
        {
            SimpleNode first = (SimpleNode) jjtree.popNode();
            SimpleNode second = (SimpleNode) jjtree.popNode();
            mult = new MULT(first.id);
            mult.value = t.image;
            mult.jjtAddChild(first, 0);
            mult.jjtAddChild(second, 1);
            jjtree.pushNode(mult);
        }
    )*
}

void COLOPERANDS()      :
{}
{
    <LPAREN> COLARITHMEXPR() <RPAREN> | SACD() | NUM()
}

void RLE()      :
{}
{/*@bgen(jjtree) #RULE(> 1) */
    {
      RULE jjtn001 = new RULE(JJTRULE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/ 
    (IDEN() (
        <DEFINERULE> EXPR() (<EOL>)+
    |   <ARGSSTART> (<EOL>)+ (PARTRLE())+ <ARGSSTOP> (<EOL>)+
    )
    )/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001, jjtree.nodeArity() > 1);
      }
    }
/*@egen*/          
}

void PARTRLE()          :
{/*@bgen(jjtree) PARTRULE */
  PARTRULE jjtn000 = new PARTRULE(JJTPARTRULE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) PARTRULE */
    try {
/*@egen*/
    IDEN() <DEFINERULE> EXPR() (<EOL>)+/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void EXPR()      :
{}
{
    OREXPR()
}

void OREXPR()      :
{ int count = 0; }
{/*@bgen(jjtree) #OR( count > 0) */
    {
      OR jjtn001 = new OR(JJTOR);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (ANDEXPR() (<OR> { count++; } ANDEXPR())*)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  count > 0);
      }
    }
/*@egen*/            
}

void ANDEXPR()      :
{ int count = 0; }
{/*@bgen(jjtree) #AND( count > 0) */
    {
      AND jjtn001 = new AND(JJTAND);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (VPEXPR() (<AND> { count++; } VPEXPR())*)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  count > 0);
      }
    }
/*@egen*/             
}

void VPEXPR()      :
{}
{
    VALEXPR()
    | <LPAREN> EXPR() <RPAREN>
}

void VALEXPR():
{/*@bgen(jjtree) VALEXPR */
  VALEXPR jjtn000 = new VALEXPR(JJTVALEXPR);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) VALEXPR */
    try {
/*@egen*/
    IDEN()
    (
        t = <IS> CONSTRAINEXPR()
    |   t = <EQUAL> (STRING() | ARITHMEXPR1())
    |   t = <COMPARISON> ARITHMEXPR1()
    |   t = <CONTAINS> STRING()
    )/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/ 
    { jjtn000.value = t.image;}/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void CONSTRAINEXPR()      :
{}
{
    CONSTRAINTS() 
}

void ARITHMEXPR1()      :
{ Token t; ADD current; }
{
    (
    ARITHMEXPR2()
    (
    (   t = "+" ARITHMEXPR2()
    |   t = "-" ARITHMEXPR2()
    )
    {
        SimpleNode first = (SimpleNode) jjtree.popNode();
        SimpleNode second = (SimpleNode) jjtree.popNode();
        current = new ADD(first.id);
        current.value = t.image;
        current.jjtAddChild(first, 0);
        current.jjtAddChild(second, 1);
        jjtree.pushNode(current);
    }
    )*
    )
}

void ARITHMEXPR2()      :
{ Token t; MULT mult; }
{
    OPERANDS() 
    (
        (
            t = "*" OPERANDS()
        |   t = "/" OPERANDS()
        |   t = "%" OPERANDS()
        )
        {
            SimpleNode first = (SimpleNode) jjtree.popNode();
            SimpleNode second = (SimpleNode) jjtree.popNode();
            mult = new MULT(first.id);
            mult.value = t.image;
            mult.jjtAddChild(first, 0);
            mult.jjtAddChild(second, 1);
            jjtree.pushNode(mult);
        }
    )*
}

void CONSTRAINTS():
{/*@bgen(jjtree) CONSTRAINTS */
  CONSTRAINTS jjtn000 = new CONSTRAINTS(JJTCONSTRAINTS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) CONSTRAINTS */
    try {
/*@egen*/
    t = <CONSTRAINT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    { jjtn000.value = t.image; } |
    t = <EMPTY>/*@bgen(jjtree)*/
                {
                  jjtree.closeNodeScope(jjtn000, true);
                  jjtc000 = false;
                }
/*@egen*/ { jjtn000.value = "EMPTY"; } |
    t = <NOT> <EMPTY>/*@bgen(jjtree)*/
                      {
                        jjtree.closeNodeScope(jjtn000, true);
                        jjtc000 = false;
                      }
/*@egen*/ { jjtn000.value = "NOTEMPTY"; }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void OPERANDS()      :
{}
{
    <LPAREN> ARITHMEXPR1() <RPAREN> | SACD() | IDEN() | NUM()
}

void STRING():
{/*@bgen(jjtree) STRING */
  STRING jjtn000 = new STRING(JJTSTRING);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) STRING */
    try {
/*@egen*/
    (t = <STRING>/*@bgen(jjtree)*/
                  {
                    jjtree.closeNodeScope(jjtn000, true);
                    jjtc000 = false;
                  }
/*@egen*/ { jjtn000.value = t.image; })/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void NUM()      :     
{}
{ INTEGER() | FLOATY() }

void INTEGER(): 
{/*@bgen(jjtree) INTEGER */
  INTEGER jjtn000 = new INTEGER(JJTINTEGER);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) INTEGER */
    try {
/*@egen*/
    t = <INT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.value = t.image;
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void FLOATY(): 
{/*@bgen(jjtree) FLOATY */
  FLOATY jjtn000 = new FLOATY(JJTFLOATY);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) FLOATY */
    try {
/*@egen*/
    t = <FLOAT>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.value = t.image;
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void STMT()      :
{}
{ ANLZ() ((<EOL>)+ | <EOF>) STMT() | <EOF> }

void ANLZ()         :
{/*@bgen(jjtree) ANALYZE */
  ANALYZE jjtn000 = new ANALYZE(JJTANALYZE);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ANALYZE */
  try {
/*@egen*/ <ANALYZE> IDEN() <WITH> IDEN() (<ARGSSTART> (<EOL>)+ ANOPTIONS() <ARGSSTOP>)?/*@bgen(jjtree)*/
  } catch (Throwable jjte000) {
    if (jjtc000) {
      jjtree.clearNodeScope(jjtn000);
      jjtc000 = false;
    } else {
      jjtree.popNode();
    }
    if (jjte000 instanceof RuntimeException) {
      throw (RuntimeException)jjte000;
    }
    if (jjte000 instanceof ParseException) {
      throw (ParseException)jjte000;
    }
    throw (Error)jjte000;
  } finally {
    if (jjtc000) {
      jjtree.closeNodeScope(jjtn000, true);
    }
  }
/*@egen*/}

void ANOPTIONS()             :
{/*@bgen(jjtree) ANLZOPTIONS */
  ANLZOPTIONS jjtn000 = new ANLZOPTIONS(JJTANLZOPTIONS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ANLZOPTIONS */
    try {
/*@egen*/
    (RULEOPT()) (ROWOPT() (COLOPT())? | COLOPT() (ROWOPT())?)?/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void RULEOPT():
{/*@bgen(jjtree) RULEOPT */
  RULEOPT jjtn000 = new RULEOPT(JJTRULEOPT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) RULEOPT */
    try {
/*@egen*/
    (IDEN() (<EOL>)+)*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ROWOPT()      :
{}
{
   ROWS() (<EOL>)+
}

void COLOPT()      :
{}
{
    COLS() (<EOL>)+
}

void ROWS():
{/*@bgen(jjtree) ROWS */
  ROWS jjtn000 = new ROWS(JJTROWS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ROWS */
    try {
/*@egen*/
    <ROW> INDEX()(<COMMA> INDEX())*/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void COLS():
{/*@bgen(jjtree) COLS */
  COLS jjtn000 = new COLS(JJTCOLS);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) COLS */
    try {
/*@egen*/
    <COL> ( IDEN()(<COMMA> IDEN())* | (INDEX()(<COMMA> (INDEX()| IDEN())*)) )/*@bgen(jjtree)*/
    } catch (Throwable jjte000) {
      if (jjtc000) {
        jjtree.clearNodeScope(jjtn000);
        jjtc000 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte000 instanceof RuntimeException) {
        throw (RuntimeException)jjte000;
      }
      if (jjte000 instanceof ParseException) {
        throw (ParseException)jjte000;
      }
      throw (Error)jjte000;
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void INDEX()      :
{ int count = 0; }
{/*@bgen(jjtree) #RANGE( count > 0) */
    {
      RANGE jjtn001 = new RANGE(JJTRANGE);
      boolean jjtc001 = true;
      jjtree.openNodeScope(jjtn001);
    }
    try {
/*@egen*/
    (INTEGER() (<TO> {count++;} INTEGER())?)/*@bgen(jjtree)*/
    } catch (Throwable jjte001) {
      if (jjtc001) {
        jjtree.clearNodeScope(jjtn001);
        jjtc001 = false;
      } else {
        jjtree.popNode();
      }
      if (jjte001 instanceof RuntimeException) {
        throw (RuntimeException)jjte001;
      }
      if (jjte001 instanceof ParseException) {
        throw (ParseException)jjte001;
      }
      throw (Error)jjte001;
    } finally {
      if (jjtc001) {
        jjtree.closeNodeScope(jjtn001,  count > 0);
      }
    }
/*@egen*/               
}

void IDEN():
{/*@bgen(jjtree) IDEN */
  IDEN jjtn000 = new IDEN(JJTIDEN);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/ Token t; }
{/*@bgen(jjtree) IDEN */
    try {
/*@egen*/
    t = <ID>/*@bgen(jjtree)*/
    {
      jjtree.closeNodeScope(jjtn000, true);
      jjtc000 = false;
    }
/*@egen*/
    {
        jjtn000.value = t.image;
    }/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void MULT():
{/*@bgen(jjtree) MULT */
  MULT jjtn000 = new MULT(JJTMULT);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) MULT */
    try {
/*@egen*/
    "*"/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}

void ADD():
{/*@bgen(jjtree) ADD */
  ADD jjtn000 = new ADD(JJTADD);
  boolean jjtc000 = true;
  jjtree.openNodeScope(jjtn000);
/*@egen*/}
{/*@bgen(jjtree) ADD */
    try {
/*@egen*/
    "+"/*@bgen(jjtree)*/
    } finally {
      if (jjtc000) {
        jjtree.closeNodeScope(jjtn000, true);
      }
    }
/*@egen*/
}